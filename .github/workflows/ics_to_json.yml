name: ICS to JSON

on:
  workflow_dispatch:
    inputs:
      force:
        description: 'Force regeneration even if ICS is unchanged'
        required: false
        default: false
        type: boolean
      enrich_titles:
        description: 'Fetch event page subtitle into title field (default true)'
        required: false
        default: true
        type: boolean
  schedule:
    - cron: '0 * * * *'

permissions:
  contents: write
  issues: write

jobs:
  build-and-publish:
    # Ensure this only runs on the main branch
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    env:
      ICS_URL: ${{ vars.ICS_URL }}
      REPO_VARIABLE: ${{ vars.REPO_VARIABLE }}
      OUTPUT_FILE: ${{ vars.OUTPUT_FILE }}
      FALLBACK_PREPEND_TEXT: ${{ vars.FALLBACK_PREPEND_TEXT }}
      FORCE_REBUILD: ${{ github.event.inputs.force }}
      # Logic for enrichment flag: always on for schedule, respects input for dispatch
      ENRICH_FLAG: ${{ (github.event_name == 'schedule' || github.event.inputs.enrich_titles == 'true') && '--enrich-titles' || '' }}
    # Always include raw details and raw extracts in production builds
    RAW_DETAILS_FLAG: "--enrich-raw-details"
    EXTRACT_FLAGS: "--enrich-raw-extracts"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Load failure streak
        id: load_streak
        run: |
          count=$(cat .ci/failure-streak 2>/dev/null || echo 0)
          echo "current=$count" >> "$GITHUB_OUTPUT"

      - name: Check ICS change
        id: check_change
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${ICS_URL}" ]; then echo "ICS_URL not set" >&2; exit 1; fi
          
          curl -fsSL "$ICS_URL" -o current.ics
          new_hash=$(sha256sum current.ics | cut -d ' ' -f1)
          echo "New ICS SHA256: $new_hash"
          
          # For main branch, previous hash is always from the 'latest' release
          prev_hash=$(gh release view latest --json body -q '.body' 2>/dev/null | grep -Eo 'ICS_SHA256:[0-9a-f]+' | cut -d: -f2 || echo "")
          echo "Previous ICS SHA256: ${prev_hash:-<none>}"
          
          if [ "${FORCE_REBUILD:-false}" = "true" ]; then
            echo "Force rebuild requested." >> "$GITHUB_STEP_SUMMARY"
            echo "skip=false" >> "$GITHUB_OUTPUT"
          elif [ "$new_hash" = "$prev_hash" ] && [ -n "$prev_hash" ]; then
            echo "ICS unchanged; skipping generation." >> "$GITHUB_STEP_SUMMARY"
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi
          echo "hash=$new_hash" >> "$GITHUB_OUTPUT"

      - name: Set up Python, install, and test
        if: steps.check_change.outputs.skip != 'true'
        run: |
          pip install -r requirements.txt
          pytest -q

      - name: Generate JSON
        if: steps.check_change.outputs.skip != 'true'
        run: |
          python -m src.main --ics-url "${ICS_URL}" --repo-variable "${REPO_VARIABLE}" --output "${OUTPUT_FILE:-events.json}" ${ENRICH_FLAG} ${RAW_DETAILS_FLAG} ${EXTRACT_FLAGS}

      - name: Validate JSON against schema
        if: steps.check_change.outputs.skip != 'true'
        run: |
          python tools/validate_json.py --schema schema/events.schema.json --data "${OUTPUT_FILE:-events.json}"

      - name: Publish "latest" release
        if: steps.check_change.outputs.skip != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          OUTPUT_ASSET="${OUTPUT_FILE:-events.json}"
          TAG="latest"
          TITLE="Latest Events"
          BODY="Automated update of events feed. ICS_SHA256:${{ steps.check_change.outputs.hash }}"

          # Overwrite existing 'latest' release
          gh release delete "$TAG" -y 2>/dev/null || true
          gh release create "$TAG" "$OUTPUT_ASSET" --title "$TITLE" --notes "$BODY" --latest

      - name: Upload JSON artifact
        if: steps.check_change.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: events-json
          path: ${{ env.OUTPUT_FILE || 'events.json' }}

      - name: Handle success/failure streak
        if: always() # This step runs regardless of job status
        uses: ./actions/update-failure-streak # Assumes you move the logic to a local action for cleanliness
        with:
          job-status: ${{ job.status }}
          streak-file: .ci/failure-streak
          github-token: ${{ secrets.GITHUB_TOKEN }}